#### 什么是字符串常量池？

字符串常量池位于堆内存中，专门用来存储字符串常量，可以提高内存的使用率，避免开辟多块空间存储相同的字符串，在创建字符串时 JVM 会首先检查字符串常量池，如果该字符串已经存在池中，则返回它的引用，如果不存在，则实例化一个字符串放到池中，并返回其引用。





## 运行时公有数据区

### 堆

- 所有jvm线程共享
- 所有为类实例和数组分配的内存都来自于它

### 方法区

- 所有jvm线程共享
- 存储类的结构。像运行时常量池，字段和方法数据，方法和构造函数的代码，还有特殊的方法用于类和实例的初始化，以及接口的初始化

### 运行时常量池

类或接口的字节码文件里的常量池的运行时表示形式。如在编译时就已经知道的数字字面量值，和必须在运行时解析的方法和字段的引用，运行时常量池的功能类似于传统语言的符号表，不过它包含的数据会更加宽泛。

运行时常量池分配在jvm的方法区，类或接口的运行时常量池在类或接口被jvm创建时才会构建。



## 运行时私有数据区

### pc寄存器

### jvm栈

栈中存储的是帧。方法调用是以帧的形式进行的。帧用来存储数据和部分计算结果，和执行动态链接，方法返回值，分发异常。

在一个线程执行的任何时刻，都只会有一个帧是处于激活的。这个帧被称为当前帧，与之对应的方法被称为当前方法，方法所在的类被称为当前类，此时用到的本地变量数组和操作数栈也都是当前帧的。

当它调用的是本地方法时，虚拟机会保持 Java 栈不变，不会在 Java 栈祯中压入新的祯，虚拟机只是简单地动态连接并直接调用指定的本地方法。

jvm栈主要用于帧的出栈和入栈。

- ##### 帧：每一个帧都有自己的本地变量数组，自己的操作数据栈，和一个对当前方法所在类的运行时常量池的引用。

  - **本地变量数组**。长度在编译时确定，随着编译后的方法代码一起提供。通常一个本地变量（的位置）能够存储一个类型的值，但是long和double类型却需要两个本地变量（的位置）才能存一个值。本地变量按索引寻址，第一个本地变量的索引是0。long和double需要消耗两个连续的索引，但却是按照较小的这个索引寻址的。不能按照较大的那个索引去读数据，但是可以写入，当然这样将使本地变量内容错乱。在方法被调用时，jvm使用本地变量来接收传递进来的参数值。在类（静态）方法调用时，所有参数被传入从索引0开始的连贯的本地变量数组里。在实例（非静态）方法调用时，索引0处总是传入正在其上执行方法调用的那个对象的引用，（就是Java中的this了），所有参数被传入从1开始的连贯的本地变量数组里。

  - **操作数栈**。每个帧包含一个后进先出的栈，用于存储正在执行的jvm指令的操作数。当帧被创建时，操作数栈是空的，jvm提供一些指令用于加载常量值，本地变量值，字段值到操作数栈上，另一些jvm指令采用操作数栈上的操作数进行操作，并把结果放回到操作数栈上。操作数栈也用于准备将要传递给方法调用的参数和接收方法调用返回的结果。long和double类型的值占用两个单位的栈深度，其它类型的值占用一个单位的栈深度。

  - **动态链接**。每一个帧都包含了对当前方法所属类型的运行时常量池的引用。目的是为了支持方法代码的动态链接。class文件中描述一个方法引用被调用的方法和被访问的变量的代码，是采用符号引用的形式实现的。

    符号引用的形式可以粗略的认为是字符串的形式，就是用字符串标明需要调用哪个类的哪个方法或访问哪个字段或变量。就像符号引用这个名字一样，这些仅仅是符号，是拿不到具体值的，所以必须要进行转换。

    动态链接就是把这些符号方法引用转换为具体的方法引用，在必要时加载类来解析尚未明确的符号，把符号变量的访问转换为这些变量运行时所在存储结构的适合的偏移量（索引）。这样的方式又称为后期绑定。

  - **方法调用**。一个方法调用正常完成（即没有抛异常）时，会根据所返回的值的类型执行一个适合的return指令，当前帧会去恢复调用者的状态，包括它的本地变量和操作数栈，使调用者的程序计数器适合的递增来跳过刚刚的那个方法调用指令。
  
    返回值会被放到调用者帧的操作数栈上，然后继续执行调用者方法的帧。一个方法在调用时抛出了异常，且这个异常没有在这个方法内被捕获处理，将会导致这个方法调用的突然结束，这种情况下永远不会向方法的调用者返回一个值。


### native方法栈
